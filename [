#include <stdint.h>

typedef struct{
	volatile uint32_t COMMAND;
	volatile uint32_t POINTER;
	volatile uint32_t STATUS;
	volatile uint32_t MASK;
} mailbox_generic_t;

static inline void pending_bit_write(mailbox_generic_t* device, uint32_t value){
	uint32_t old_value = device->STATUS & ~1;
	device->STATUS = old_value | (1 & value);
}

static inline uint32_t pending_bit_read(mailbox_generic_t* device){
	return (device->STATUS & 1);
}

static inline void full_bit_write(mailbox_generic_t* device, uint32_t value){
	uint32_t old_value = device->STATUS & ~(1<<1);
	device->STATUS = old_value | ((1<<1) & value);
}

static inline uint32_t full_bit_read(mailbox_generic_t* device){
	return (device->STATUS & (1<<1));
}

static inline void pending_mask_bit_write(mailbox_generic_t* device, uint32_t value){
	uint32_t old_value = device->MASK & ~1;
	device->MASK = old_value | (1 & value);
}

static inline uint32_t pending_mask_bit_read(mailbox_generic_t* device){
	return (device->MASK & 1);
}

static inline void space_mask_bit_write(mailbox_generic_t* device, uint32_t value){
	uint32_t old_value = device->MASK & ~(1<<1);
	device->MASK = old_value | ((1<<1) & value);
}

static inline uint32_t space_mask_bit_read(mailbox_generic_t* device){
	return (device->MASK & (1<<1));
}





// nope
typedef struct{
	volatile uint32_t DATA;
} mailbox_simple_t;

static inline uint32_t read_mailbox(mailbox_simple_t* device){
	return device->DATA;
}

static inline void write_mailbox(mailbox_simple_t* device, uint32_t value){
	device->DATA = value;
}


typedef struct{
	union {
		volatile uint32_t RAW;
    struct {
			volatile uint8_t a0;
			volatile uint8_t a1;
			volatile uint8_t a2;
			volatile uint8_t a3;
		} bytes;
	};
} i2c_atom_t;


typedef struct{
	uint32_t SIZE;
	i2c_atom_t* START_ADDR;
} i2c_message_t;


typedef struct{
  uint32_t HEAD;
  uint32_t TAIL;
  i2c_atom_t *BUFFER;
} i2c_buffer_t;


typedef struct{
	uint32_t BUFFER_;
} i2c_config_t;


static inline i2c_buffer_t* malloc_i2c_buffer(uint32_t buffer_size){
	i2c_buffer_t* newBuffer = malloc(sizeof(i2c_buffer_t));

	newBuffer->BUFFER = malloc(buffer_size*sizeof(i2c_atom_t));
	newBuffer->HEAD = 0;
	newBuffer->TAIL = 0;

	return newBuffer;
}


// Warning this does not check if memory addresses are being used
static inline i2c_buffer_t* mm_fixed_i2c_buffer(uint32_t buffer_size, uint32_t memory_address){
	uint32_t base_address = memory_address;
	uint32_t buffer_address = memory_address + sizeof(i2c_buffer_t);

	volatile i2c_atom_t* buffer_array = (volatile i2c_atom_t*) buffer_address;
	volatile i2c_buffer_t* access_struct = (volatile i2c_buffer_t*) base_address;

	access_struct->BUFFER = buffer_array;
	access_struct->HEAD=0;
	access_struct->TAIL=0;

	return access_struct;
}

typedef enum{
	IDLE    = 0x00 , // I2C not running, CPU is doing other things waiting for interruption
	READING = 0x01 , // getting atoms from mailbox
	WORKING = 0x02   // placeholder for future commands
} i2c_slave_state_t;


typedef enum {
	MODE_DEBUG    = 0xF0,
	MODE_REGULAR  = 0x0F,
	SEND_POSITION = 0x00,
	SEND_INTERVAL = 0x01,
} i2c_commands_t;

